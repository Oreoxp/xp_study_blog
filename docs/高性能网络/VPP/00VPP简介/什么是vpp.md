**VPP 学习笔记：基础概念入门**

#### **1. 什么是 VPP (Vector Packet Processor)？**

FD.io 的矢量报文处理（VPP）是一个快速、可扩展、支持多平台的二到四层网络协议栈。 它作为一个用户态（Userspace）应用运行在 Linux 系统上，并支持多种 CPU 架构，包括 x86、ARM 和 PowerPC。

凭借其卓越的性能，VPP 正迅速成为全球各类网络应用的首选协议栈。

**VPP 的核心特点：**

*   **插件化架构 (Plugins):** VPP 的功能通过插件机制不断增强。其中一个典型的例子就是数据平面开发套件 **(DPDK)**，它为 VPP 提供了许多重要的功能和驱动程序。
*   **生态集成:** VPP 支持与 OpenStack 和 Kubernetes 等云原生平台集成。
*   **强大的管理与开发功能:**
    *   **网络管理:** 提供配置、计数器、采样等功能。
    *   **开发者工具:** 包含高性能事件日志、多种报文追踪工具。其开发调试镜像（debug images）提供完整的符号表和大量的（数据、逻辑）一致性检查功能。
*   **应用场景:** VPP 的常见用例包括虚拟交换机 (vSwitches)、虚拟路由器 (vRouters)、网关 (Gateways)、防火墙 (Firewalls) 和负载均衡器 (Load-Balancers) 等。

#### **2. 核心思想：矢量处理 vs 标量处理**

VPP 的高性能秘诀在于它采用了 **矢量报文处理 (Vector Packet Processing)** 技术，这与传统的 **标量报文处理 (Scalar Packet Processing)** 方式形成了鲜明对比。

矢量处理是 FD.io VPP 和 DPDK 等高性能报文处理应用的通用方法。而对于性能要求不那么严格的网络栈，则倾向于使用标量处理方法。

---

##### **2.1 标量报文处理 (Scalar Packet Processing)**

传统的标量网络栈一次只处理一个报文。处理流程通常是：一个中断处理函数从网卡接收**单个报文**，然后让这个报文在一系列函数中被依次处理：`函数A` 调用 `函数B`，`函数B` 再调用 `函数C`，以此类推。

**处理流程示意：**
```
+---> 函数A(报文1) +---> 函数B(报文1) +---> 函数C(报文1)
+---> 函数A(报文2) +---> 函数B(报文2) +---> 函数C(报文2)
...
+---> 函数A(报文N) +---> 函数B(报文N) +---> 函数C(报文N)
```

**标量处理虽然简单，但效率低下，主要体现在两个方面：**

1.  **指令缓存 (I-cache) 颠簸:** 当处理一个报文所经过的代码路径长度超过了CPU的指令缓存大小时，CPU就需要不断地加载新的指令，导致缓存颠簸 (thrashing)。在这种模型下，**每个报文都会引发一系列相同的指令缓存未命中 (I-cache miss)**。
2.  **数据缓存 (D-cache) 压力:** 这种函数层层调用的模式会产生很深的调用栈，这会给CPU的一级数据缓存 (L1 D-cache) 带来额外的加载/存储压力。

---

##### **2.2 矢量报文处理 (Vector Packet Processing)**

与标量处理不同，VPP 一次性处理多个报文，这些报文组成一个集合，称为“报文矢量 (vector of packets)”。处理流程是：中断处理函数从网卡一次性获取**一批报文（一个矢量）**，然后将整个矢量传递给处理函数网络。

**处理流程示意：**
```
+---> 函数A([报文1, 报文2, ..., 报文256])
     +---> 函数B([报文1, 报文2, ..., 报文256])
          +---> 函数C([报文1, 报文2, ..., 报文256])
```

**矢量处理的优势：**

这种方式有效地解决了标量处理的效率问题：

1.  **解决 I-cache 颠簸:** 通过将加载指令的成本**摊销**到多个报文上，解决了指令缓存颠簸问题。处理矢量中的第一个报文时，相关的指令就会被加载到缓存中（俗称“预热缓存”），后续的报文可以直接利用这些已缓存的指令，大大减少了 I-cache miss 的次数。
2.  **避免深度调用栈:** VPP 从网卡一次最多接收256个报文，并使用一个**有向图 (directed graph of node)** 的结构来处理它们。图调度器 (graph scheduler) 一次只调用一个节点的分发函数，从而将调用栈的深度限制在几个栈帧之内，解决了调用栈过深带来的效率问题。
3.  **开启更多优化:** 这种模式还带来了流水线 (pipelining) 和预取 (prefetching) 等进一步优化的可能性，从而最大限度地减少读取表数据时的延迟，并使处理报文所需的并行加载成为可能。



#### **3. 报文处理图 (The Packet Processing Graph) 的核心地位**

在 FD.io VPP 的设计中，**报文处理图 (Packet Processing Graph)** 是其绝对的核心。

这种设计的优势使得 VPP 软件具备以下特点：

- **可插拔、易于理解和扩展 (Pluggable, easy to understand & extend):** 功能模块可以像插件一样轻松添加或移除。
- **成熟的图节点架构 (Mature graph node architecture):** 拥有稳定、可靠的架构基础。
- **完全控制处理流程 (Full control to reorganize the pipeline):** 可以灵活地重组和定制报文处理的流水线。
- **高性能，插件是“一等公民” (Fast, plugins are equal citizens):** 插件与 VPP 核心组件享有同等的性能待遇，没有性能损失。

VPP 的报文处理流水线被分解成一个“报文处理图”。这种模块化的方法意味着任何人都可以“插入”新的图节点 (graph nodes) 来扩展功能。这使得 VPP 易于扩展，并且可以为特定目的定制插件。同时，VPP 也可以通过其底层 API (Low-Level API) 进行配置。

------



#### **4. 可扩展、模块化的图节点架构**

VPP 的架构是如何实现可扩展和模块化的呢？

在运行时，FD.io VPP 平台会从网卡的接收环（RX rings）中构建一个报文矢量（通常单个矢量最多包含256个报文）。然后，这个**完整的报文矢量**会依次经过处理图中的一个个节点（包括插件添加的节点）。当报文矢量流经某个图节点时，该节点代表的网络处理逻辑会依次应用到矢量中的**每一个报文**上。

图节点的特点是：

- **小巧且模块化 (small and modular)**
- **松耦合 (loosely coupled)**

这些特性使得引入新的图节点或重排现有图节点变得非常容易。

- 插件本质上是**共享库 (.so)**，VPP 在启动时会动态加载它们。
- VPP 会在指定的插件路径中搜索这些库文件，并在启动时依次加载。
- 插件可以向 VPP 中引入全新的图节点，或者重新编排现有的报文处理图。
- 你可以**完全独立于 FD.io VPP 的主源码树来构建自己的插件**，这意味着你可以将插件作为一个独立的组件来开发和维护。

------



#### **5. VPP 的网络栈功能特性 (Network Stack Features)**

以下是 FD.io VPP 网络栈的一些主要功能特性：

- 为路由表 (routes)、桥接条目 (bridge entries) 提供了快速的查找表。
- 支持任意 N 元组分类器 (Arbitrary n-tuple classifiers)。

- 同时支持 **Linux** 和 **FreeBSD** 操作系统。
- 支持标准的操作系统接口，如 AF_Packet、Tun/Tap 和 Netmap。
- 通过 **DPDK** 支持各类网络硬件和加密硬件。

- 支持半虚拟化接口：**Vhost-user** 和 **Virtio**。
- 支持基于 PCI 直通 (passthrough) 的网络适配器。
- 支持原生容器接口：**MemIF (Memory Interface)**。

- **统一数据平面 (Universal Data Plane):** VPP 的目标是提供一个统一的代码库，以满足多种不同的使用场景。
  - **独立网络设备:** 如物理路由器、交换机。
  - **云基础设施和虚拟网络功能 (VNF)。**

- **单一二进制包:** 所有用例都使用同一个二进制包进行部署。
- **生产级质量:** 开箱即用，具备生产环境要求的质量和稳定性（官方文档在此感谢了 CSIT 项目的贡献）。